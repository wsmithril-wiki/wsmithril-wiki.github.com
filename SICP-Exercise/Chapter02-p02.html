<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link type="image/x-icon" rel="icon" href="/favicon.ico" />
    <link type="image/x-icon" rel="shortcut icon" href="/favicon.ico" />
    <link rel="stylesheet" type="text/css" href="/css/style.css" />
    <script type="text/javascript" src="/MathJax/MathJax.js?config=TeX-AMS-MML_SVG"></script>
    <title>Chapter02-p02</title>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-35399239-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</head>
<body>
    <div class="content">
    
<h1 id="toc_1">SICP Exercises</h1>
<h2 id="toc_1.1">Chapter 02 - Part.II</h2>

<h3 id="toc_1.1.1">Exercise 2.42</h3>
<p>
The "Eight-Queens Puzzle" asks how to place eight queens on a chessboard so that
no queen is in check from any other (i.e., no two queens are in the same row,
column, or diagonal). One way to solve the puzzle is to work across the board,
placing a queen in each column. Once we have placed \(k-1\) queens, we must
place the \(k\)-th queen in a position where it does not check any of the queens
already on the board. We can formulate this approach recursively: Assume that
we have already generated the sequence of all possible ways to place
\(k-1\) queens in the first \(k-1\) columns of the board. For each of these ways,
generate an extended set of positions by placing a queen in each row of the \(k\)-th
column. Now filter these, keeping only the positions for which the queen in the
\(k\)-th column is safe with respect to the other queens. This produces the sequence
of all ways to place \(k\) queens in the first \(k\) columns. By continuing this
process, we will produce not only one solution, but all solutions to the
puzzle.
</p>

<p>
We implement this solution as a procedure queens, which returns a sequence of
all solutions to the problem of placing \(n\) queens on an \(n\times n\) chessboard. Queens
has an internal procedure <code>queen-cols</code> that returns the sequence of all ways to
place queens in the first \(k\) columns of the board.
</p>

<pre class="brush: scheme">
(define (queens board-size)
  (define (queen-cols k)  
    (if (= k 0)
        (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))
</pre>

<p>
In this procedure <code>rest-of-queens</code> is a way to place \(k-1\) queens in the first
\(k-1\) columns, and <code>new-row</code> is a proposed row in which to place the queen for the
\(k\)-th column. Complete the program by implementing the representation for sets of
board positions, including the procedure <code>adjoin-position</code>, which adjoins a new
<code>row-column</code> position to a set of positions, and <code>empty-board</code>, which represents an
empty set of positions. You must also write the procedure <code>safe?</code>, which
determines for a set of positions, whether the queen in the \(k\)-th column is safe
with respect to the others. (Note that we need only check whether the new queen
is safe -- the other queens are already guaranteed safe with respect to each
other.)
</p>

<ul>
<li>
Answer:

</ul>

<pre class="brush: scheme">
; an empty map has no queens
(define empty-board ())

; the adjoint-position returns an list of k possible columns, having the k-th quene
; in the different possition
(define (adjoin-position n k cols)
    (append cols (list n)))

; is the board safe?
; since we already assume that the (k - 1) board is safe, 
; we only need to test the last queen on the board
(define (safe? k cols)
    (define (all l) (accumulate (lambda (a b) (and a b)) #t l))
    (define (any l) (accumulate (lambda (a b) (or  a b)) #f l))
    (define (diag? col la)
        (define (iter i c ret) 
            (if (null? c) ret
                (iter (+ i 1) (cdr c)
                      (cons (= (abs (- k i)) (abs (- la (car c)))) ret))))
    (any (iter 1 col '())))
    (let ((la (last cols))
          (hs (take cols (- (length cols) 1))))
    (not (or (any (map (lambda (a) (= a la)) hs)) (diag? hs la)))))
</pre>

<h2 id="toc_1.2">Exercise 2.43</h2>
<p>
Louis Reasoner is having a terrible time doing exercise 2.42. His queens
procedure seems to work, but it runs extremely slowly. (Louis never does manage
to wait long enough for it to solve even the 6×6 case.) When Louis asks Eva Lu
Ator for help, she points out that he has interchanged the order of the nested
mappings in the <code>flatmap</code>, writing it as
</p>

<pre class="brush: scheme">
(flatmap
 (lambda (new-row)
   (map (lambda (rest-of-queens)
          (adjoin-position new-row k rest-of-queens))
        (queen-cols (- k 1))))
 (enumerate-interval 1 board-size))
</pre>

<p>
Explain why this interchange makes the program run slowly. Estimate how long it
will take Louis's program to solve the eight-queens puzzle, assuming that the
program in exercise 2.42 solves the puzzle in time \(T\). 
</p>

<ul>
<li>
Answer:

</ul>

<p>
First of all, the <code>queen</code> precedure will be running in the procedure <code>safe?</code>, so
the less times <code>safe?</code> being invoked, the less time will be used solving the
puzzle.
</p>

<p>
The former <code>flatmap</code> looks like this:
</p>
<pre class="brush: scheme">
(flatmap
  (lambda (rest-of-queens)
    (map (lambda (new-row)
           (adjoin-position new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
  (queen-cols (- k 1)))
</pre>

<p>
For an 8x8 puzzle, this one will first emurate every 8x1 board with one quenee
on it, then append another column, try every possible combinations, filter out
unsafe ones, then append a third column... until all 8 quenes are on the board
safely. For an 8x8 board, 15720 times <code>safe?</code> will be invoked.
</p>

<p>
As for Louis's solution, with the two iterative flipped, this precedure solving
an 8x8 problem by solving every 7x8, 6x8, ..., 1x8 problem, append another
column, filter out "unsafe" ones, and return the result. Apperently, solving
6x8, 5x8, ..., 1x8 problems are not necessary here, and worese, this precedure
will try solve each of the 7x8, 6x8, ..., 1x8 problem in a same manner, that is
to solving 7x8 problem, it needs to solve 6x8, ..., 1x8 problems, and to solve
the 6x8 problem inside the 7x8 problem, it needs to solve 5x8, ..., 1x8
problems... That is why it seems take forever even when \(n\) is not too large.
</p>

<p>
The original solution is basicaly enumerate every possible position of queens on
the board, so it has an complacity of \(O(n^n)\) or \(O(n^(-\frac 12)n!)\). And with
the flipped iterative, solving a \(n\times n\) problem will result in solving each
smaller board in a full recursive manner, so the time complacity would be \(O(n^{n^n})\).
</p>

<p>
Here are some test: (measured in times of <code>safe?</code> invoked, this should be the
same in different implementations of <code>safe?</code>)
<table>
<tr>
<th>
n
</th>
<th>
original
</th>
<th>
flipped
</th>
<th>
ratio (flipped / original)
</th>
</tr>
<tr>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1.0
</td>
</tr>
<tr>
<td>
2
</td>
<td>
6
</td>
<td>
8
</td>
<td>
1.33
</td>
</tr>
<tr>
<td>
3
</td>
<td>
60
</td>
<td>
18
</td>
<td>
3.33
</td>
</tr>
<tr>
<td>
4
</td>
<td>
624
</td>
<td>
60
</td>
<td>
10.4
</td>
</tr>
<tr>
<td>
5
</td>
<td>
8160
</td>
<td>
220
</td>
<td>
37.09
</td>
</tr>
<tr>
<td>
6
</td>
<td>
128904
</td>
<td>
894
</td>
<td>
144.189
</td>
</tr>
</table>
</p>

<h3 id="toc_1.2.1">Exercise 2.44</h3>
<p>
Define the procedure up-split used by <code>corner-split</code>. It is similar to
<code>right-split</code>, except that it switches the roles of below and beside. 
</p>

<ul>
<li>
Answer:

</ul>

<pre class="brush: scheme">
(define (up-split painter n)
  (if (= n 0) painter
      (let ((smaller (up-split painter (- n 1))))
      (below painter(beside smaller smaller)))))
</pre>

<h3 id="toc_1.2.2">Exercise 2.45</h3>

<p>
<code>right-split</code> and <code>up-split</code> can be expressed as instances of a general splitting
operation. Define a procedure <code>split</code> with the property that evaluating
</p>

<pre class="brush: scheme">
(define right-split (split beside below))
(define up-split (split below beside))
</pre>

<p>
produces procedures <code>right-split</code> and <code>up-split</code> with the same behaviors as the ones
already defined. 
</p>

<ul>
<li>
Answer:

</ul>

<pre class="brush: scheme">
(define (splite c1 c2) (lambda (painter n) 
    (if (= n 0) painter
        (let ((smaller ((split c1 c1) painter (- n 1))))
        (c1 painter (c2 smaller smaller))))))
</pre>

<h3 id="toc_1.2.3">Exercise 2.46</h3>
<p>
A two-dimensional vector <strong>v</strong> running from the origin to a point can be represented
as a pair consisting of an x-coordinate and a y-coordinate. Implement a data
abstraction for vectors by giving a constructor <code>make-vect </code>and corresponding
selectors <code>xcor-vect</code> and <code>ycor-vect</code>. In terms of your selectors and constructor,
implement procedures <code>add-vect</code>, <code>sub-vect</code>, and <code>scale-vect</code> that perform the
operations vector addition, vector subtraction, and multiplying a vector by
a scalar: 
</p>

\[
\begin{alignat}{1}
\left(x_1,y_1\right) &amp;+&amp; \left(x_2,y_2\right) &amp;=&amp; \left(x_1+x_2,y_1+y_2\right) \cr
\left(x_1,y_1\right) &amp;+&amp; \left(x_2,y_2\right) &amp;=&amp; \left(x_1-x_2,y_1-y_2\right) \cr
a &amp;\cdot&amp; \left(x,y\right) &amp;=&amp; \left(ax,ay\right) \cr
\end{alignat}
\]

<ul>
<li>
Answer:

</ul>

<pre class="brush: scheme">
(define make-vect cons)
(define xcor-vect car)
(define ycor-vect cdr)
(define (add-vect v1 v2)
    (make-vect (+ (xcor-vect v1) (xcor-vect v2))
               (+ (ycor-vect v1) (ycor-vect v2))))
(define (sub-vect v1 v2)
    (make-vect (- (xcor-vect v1) (xcor-vect v2))
               (- (ycor-vect v1) (ycor-vect v2))))
(define (scale-vect a v)
    (make-vect (* a (xcor-vect v)) (* a (ycor-vect v))))
</pre>

<h3 id="toc_1.2.4">Exercise 2.47</h3>
<p>
Here are two possible constructors for frames:
</p>

<pre class="bruch: scheme">
(define (make-frame origin edge1 edge2)
  (list origin edge1 edge2))

(define (make-frame origin edge1 edge2)
  (cons origin (cons edge1 edge2)))
</pre>

<p>
For each constructor supply the appropriate selectors to produce an
implementation for frames. 
</p>

<ul>
<li>
Answer:

</ul>

<pre class="brush: scheme">
; first two are the same
(define origin-frame car)
(define edge1-frame cadr)

; edge2 using list
(define edge2-frame caddr)

; edge2 using cons
(define edge2-frame cddr)
</pre>

<h3 id="toc_1.2.5">Exercise 2.48</h3>
<p>
A directed line segment in the plane can be represented as a pair of vectors --
the vector running from the origin to the start-point of the segment, and the
vector running from the origin to the end-point of the segment. Use your vector
representation from exercise 2.46 to define a representation for segments with
a constructor <code>make-segment</code> and selectors <code>start-segment</code> and <code>end-segment</code>. 
</p>

<ul>
<li>
Answer:

</ul>

<div class="toc">
<ul>
<li><a href="#toc_1">SICP Exercises</a>
<ul>
<li><a href="#toc_1.1">Chapter 02 - Part.II</a>
<ul>
<li><a href="#toc_1.1.1">Exercise 2.42</a>
</ul>
<li><a href="#toc_1.2">Exercise 2.43</a>
<ul>
<li><a href="#toc_1.2.1">Exercise 2.44</a>
<li><a href="#toc_1.2.2">Exercise 2.45</a>
<li><a href="#toc_1.2.3">Exercise 2.46</a>
<li><a href="#toc_1.2.4">Exercise 2.47</a>
<li><a href="#toc_1.2.5">Exercise 2.48</a>
</ul>
</ul>
</ul>
</div>

    </div>

    <div class="copyright">
        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/"><img alt="知识共享许可协议" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/2.5/cn/88x31.png" /></a>
        <br />
        本作品由<span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">WsMithril</span>创作，采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/">知识共享署名-非商业性使用-相同方式共享 2.5 中国大陆许可协议</a>进行许可。
    </div>
     
    <div id="disqus_thread"></div>

    <footer>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </footer>
</body>
</script>
<script src="/js/jquery-1.4.2.min.js" type="text/javascript"></script>
<script src="/js/wiki.js" type="text/javascript"></script>
</html>
