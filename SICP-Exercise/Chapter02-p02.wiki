= SICP Exercises =
== Chapter 02 - Part.II ==

=== Exercise 2.42 ===
The "Eight-Queens Puzzle" asks how to place eight queens on a chessboard so that
no queen is in check from any other (i.e., no two queens are in the same row,
column, or diagonal). One way to solve the puzzle is to work across the board,
placing a queen in each column. Once we have placed $k-1$ queens, we must
place the $k$-th queen in a position where it does not check any of the queens
already on the board. We can formulate this approach recursively: Assume that
we have already generated the sequence of all possible ways to place
$k-1$ queens in the first $k-1$ columns of the board. For each of these ways,
generate an extended set of positions by placing a queen in each row of the $k$-th
column. Now filter these, keeping only the positions for which the queen in the
$k$-th column is safe with respect to the other queens. This produces the sequence
of all ways to place $k$ queens in the first $k$ columns. By continuing this
process, we will produce not only one solution, but all solutions to the
puzzle.

We implement this solution as a procedure queens, which returns a sequence of
all solutions to the problem of placing $n$ queens on an $n\times n$ chessboard. Queens
has an internal procedure `queen-cols` that returns the sequence of all ways to
place queens in the first $k$ columns of the board.

{{{class="brush: scheme"
(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))
}}}

In this procedure `rest-of-queens` is a way to place $k-1$ queens in the first
$k-1$ columns, and `new-row` is a proposed row in which to place the queen for the
$k$-th column. Complete the program by implementing the representation for sets of
board positions, including the procedure `adjoin-position`, which adjoins a new
`row-column` position to a set of positions, and `empty-board`, which represents an
empty set of positions. You must also write the procedure `safe?`, which
determines for a set of positions, whether the queen in the $k$-th column is safe
with respect to the others. (Note that we need only check whether the new queen
is safe -- the other queens are already guaranteed safe with respect to each
other.)

- Answer:

{{{class="brush: scheme"
; an empty map has no queens
(define empty-board ())

; the adjoint-position returns an list of k possible columns, having the k-th quene
; in the different possition
(define (adjoin-position n k cols)
    (append cols (list n)))

; is the board safe?
; since we already assume that the (k - 1) board is safe,
; we only need to test the last queen on the board
(define (safe? k cols)
    (define (all l) (accumulate (lambda (a b) (and a b)) #t l))
    (define (any l) (accumulate (lambda (a b) (or  a b)) #f l))
    (define (diag? col la)
        (define (iter i c ret)
            (if (null? c) ret
                (iter (+ i 1) (cdr c)
                      (cons (= (abs (- k i)) (abs (- la (car c)))) ret))))
    (any (iter 1 col '())))
    (let ((la (last cols))
          (hs (take cols (- (length cols) 1))))
    (not (or (any (map (lambda (a) (= a la)) hs)) (diag? hs la)))))
}}}

== Exercise 2.43 ==
Louis Reasoner is having a terrible time doing exercise 2.42. His queens
procedure seems to work, but it runs extremely slowly. (Louis never does manage
to wait long enough for it to solve even the 6Ã—6 case.) When Louis asks Eva Lu
Ator for help, she points out that he has interchanged the order of the nested
mappings in the `flatmap`, writing it as

{{{class="brush: scheme"
(flatmap
 (lambda (new-row)
   (map (lambda (rest-of-queens)
          (adjoin-position new-row k rest-of-queens))
        (queen-cols (- k 1))))
 (enumerate-interval 1 board-size))
}}}

Explain why this interchange makes the program run slowly. Estimate how long it
will take Louis's program to solve the eight-queens puzzle, assuming that the
program in exercise 2.42 solves the puzzle in time $T$.

- Answer:

First of all, the `queen` precedure will be running in the procedure `safe?`, so
the less times `safe?` being invoked, the less time will be used solving the
puzzle.

The former `flatmap` looks like this:
{{{class="brush: scheme"
(flatmap
  (lambda (rest-of-queens)
    (map (lambda (new-row)
           (adjoin-position new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
  (queen-cols (- k 1)))
}}}

For an 8x8 puzzle, this one will first emurate every 8x1 board with one quenee
on it, then append another column, try every possible combinations, filter out
unsafe ones, then append a third column... until all 8 quenes are on the board
safely. For an 8x8 board, 15720 times `safe?` will be invoked.

As for Louis's solution, with the two iterative flipped, this precedure solving
an 8x8 problem by solving every 7x8, 6x8, ..., 1x8 problem, append another
column, filter out "unsafe" ones, and return the result. Apperently, solving
6x8, 5x8, ..., 1x8 problems are not necessary here, and worese, this precedure
will try solve each of the 7x8, 6x8, ..., 1x8 problem in a same manner, that is
to solving 7x8 problem, it needs to solve 6x8, ..., 1x8 problems, and to solve
the 6x8 problem inside the 7x8 problem, it needs to solve 5x8, ..., 1x8
problems... That is why it seems take forever even when $n$ is not too large.

The original solution is basicaly enumerate every possible position of queens on
the board, so it has an complacity of $O(n^n)$ or $O(n^{-\frac 12}n!)$. And with
the flipped iterative, solving a $n\times n$ problem will result in solving each
smaller board in a full recursive manner, so the time complacity would be $O(n^{n^n})$.

Here are some test: (measured in times of `safe?` invoked, this should be the
same in different implementations of `safe?`)
| n | original | flipped | ratio (flipped / original) |
|---|----------|---------|----------------------------|
| 1 | 1        | 1       | 1.0                        |
| 2 | 6        | 8       | 1.33                       |
| 3 | 60       | 18      | 3.33                       |
| 4 | 624      | 60      | 10.4                       |
| 5 | 8160     | 220     | 37.09                      |
| 6 | 128904   | 894     | 144.189                    |

=== Exercise 2.44 ===
Define the procedure up-split used by `corner-split`. It is similar to
`right-split`, except that it switches the roles of below and beside.

- Answer:

{{{class="brush: scheme"
(define (up-split painter n)
  (if (= n 0) painter
      (let ((smaller (up-split painter (- n 1))))
      (below painter(beside smaller smaller)))))
}}}

=== Exercise 2.45 ===

`right-split` and `up-split` can be expressed as instances of a general splitting
operation. Define a procedure `split` with the property that evaluating

{{{class="brush: scheme"
(define right-split (split beside below))
(define up-split (split below beside))
}}}

produces procedures `right-split` and `up-split` with the same behaviors as the ones
already defined.

- Answer:

{{{class="brush: scheme"
(define (splite c1 c2) (lambda (painter n)
    (if (= n 0) painter
        (let ((smaller ((split c1 c1) painter (- n 1))))
        (c1 painter (c2 smaller smaller))))))
}}}

=== Exercise 2.46 ===
A two-dimensional vector *v* running from the origin to a point can be represented
as a pair consisting of an x-coordinate and a y-coordinate. Implement a data
abstraction for vectors by giving a constructor `make-vect `and corresponding
selectors `xcor-vect` and `ycor-vect`. In terms of your selectors and constructor,
implement procedures `add-vect`, `sub-vect`, and `scale-vect` that perform the
operations vector addition, vector subtraction, and multiplying a vector by
a scalar:

{{$
\begin{alignat}{1}
\left(x_1,y_1\right) &+& \left(x_2,y_2\right) &=& \left(x_1+x_2,y_1+y_2\right) \cr
\left(x_1,y_1\right) &+& \left(x_2,y_2\right) &=& \left(x_1-x_2,y_1-y_2\right) \cr
a &\cdot& \left(x,y\right) &=& \left(ax,ay\right) \cr
\end{alignat}
}}$

- Answer:

{{{class="brush: scheme"
(define make-vect cons)
(define xcor-vect car)
(define ycor-vect cdr)
(define (add-vect v1 v2)
    (make-vect (+ (xcor-vect v1) (xcor-vect v2))
               (+ (ycor-vect v1) (ycor-vect v2))))
(define (sub-vect v1 v2)
    (make-vect (- (xcor-vect v1) (xcor-vect v2))
               (- (ycor-vect v1) (ycor-vect v2))))
(define (scale-vect a v)
    (make-vect (* a (xcor-vect v)) (* a (ycor-vect v))))
}}}

=== Exercise 2.47 ===
Here are two possible constructors for frames:

{{{class="bruch: scheme"
(define (make-frame origin edge1 edge2)
  (list origin edge1 edge2))

(define (make-frame origin edge1 edge2)
  (cons origin (cons edge1 edge2)))
}}}

For each constructor supply the appropriate selectors to produce an
implementation for frames.

- Answer:

{{{class="brush: scheme"
; first two are the same
(define origin-frame car)
(define edge1-frame cadr)

; edge2 using list
(define edge2-frame caddr)

; edge2 using cons
(define edge2-frame cddr)
}}}

=== Exercise 2.48 ===
A directed line segment in the plane can be represented as a pair of vectors --
the vector running from the origin to the start-point of the segment, and the
vector running from the origin to the end-point of the segment. Use your vector
representation from exercise 2.46 to define a representation for segments with
a constructor `make-segment` and selectors `start-segment` and `end-segment`.

- Answer:

{{{class="brush: scheme"
(define make-segment cons)
(define start-segment car)
(define end-segment cdr)
}}}

=== Exercise 2.49 ===
Use segments->painter to define the following primitive painters:

a.  The painter that draws the outline of the designated frame.

b.  The painter that draws an ``X'' by connecting opposite corners of the frame.

c.  The painter that draws a diamond shape by connecting the midpoints of the sides of the frame.

d.  The wave painter.

- Answer:

{{{class="brush: scheme"
; outline
(define outline (lambda (frame)
    (let ((p1 (origin-vect frame))
          (p2 (add-vect (origin-vect frame) (edge1-vect frame)))
          (p3 (add-vect (origin-vect frame) (add-vect (edge1-vect frame) (edge2-vect frame)))
          (p4 (add-vect (origin-vect frame) (edge2-vect frame)))))
    (segments->painter (list (make-segment p1 p2) (make-segment p2 p3)
                             (make-segment p3 p4) (make-segment p4 p1))))))

; X mark
(define X (lambda (frame)
    (let ((p1 (origin-vect frame))
          (p2 (add-vect (origin-vect frame) (edge1-vect frame)))
          (p3 (add-vect (origin-vect frame) (add-vect (edge1-vect frame) (edge2-vect frame)))
          (p4 (add-vect (origin-vect frame) (edge2-vect frame)))))
    (segments->painter (list (make-segment p1 p3) (make-segment p2 p4))))))

; diamond
(define diamond (lambda (frame)
    (define (midpoint p1 p2) (scale-vect 0.5 (add-vect p1 p2)))
    (let ((p1 (origin-vect frame))
          (p2 (add-vect (origin-vect frame) (edge1-vect frame)))
          (p3 (add-vect (origin-vect frame) (add-vect (edge1-vect frame) (edge2-vect frame)))
          (p4 (add-vect (origin-vect frame) (edge2-vect frame)))))
    (let ((m1 (midpoint p1 p2))
          (m2 (midpoint p2 p3))
          (m3 (midpoint p3 p4))
          (m4 (midpoint p4 p0)))
    (segment->painter (list (make-segment m1 m2) (make-segment m2 m3)
                            (make-segment m3 m4) (make-segment m4 m1)))))))
; nothing new in wave, skip
}}}

=== Exercise 2.50 ===
Define the transformation `flip-horiz`, which flips painters horizontally, and
transformations that rotate painters counterclockwise by 180 degrees and 270
degrees.

- Answer:

{{{class="brush: scheme"
(define (flip-horiz painter)
    (transform-painter painter (make-vert 1.0 0.0)
                               (make-vert 0.0 0.0)
                               (make-vert 1.0 1.0)))
(define (rotate-180 painter)
    (transform-painter painter (make-vert 1.0 1.0)
                               (make-vert 0.0 1.0)
                               (make-vert 1.0 0.0)))
(define (rotate-270 painter)
    (transform-painter painter (make-vert 1.0 0.0)
                               (make-vert 1.0 1.0)
                               (make-vert 0.0 0.0)))
}}}

=== Exercise 2.51 ===
Define the `below` operation for painters. Below takes two painters as arguments.
The resulting painter, given a frame, draws with the first painter in the bottom
of the frame and with the second painter in the top.  Define below in two
different ways -- first by writing a procedure that is analogous to the `beside`
procedure given above, and again in terms of beside and suitable rotation
operations (from exercise 2.50).

- Answer:

{{{class="brush: scheme"
; in a way analogous to beside
(define (below painter1 painter2)
    (let ((mid-point (make-vert 0.0 0.5)))
    (let ((top-part (transform-painter painter2 mid-point
                                                (make-vert 0.5 1.0)
                                                (make-vert 1.0 1.0)))
          (bot-part (transform-painter painter1 (make-vert 0.0 0.0)
                                                (make-vert 1.0 0.0)
                                                mid-point)))
    (lambda (frame)
    (top-part frame)
    (bot-part frame)))))

; using rotates and beside
(define (below painter1 painter2)
    (rotate-90 (beside (rotate-270 painter2) (rotate-270 painter1))))
}}}

=== Exercise 2.52 ===
Make changes to the square limit of wave shown in figure 2.9 by working at each
of the levels described above. In particular:

a.  Add some segments to the primitive wave painter of exercise  2.49 (to add
a smile, for example).

b.  Change the pattern constructed by corner-split (for example, by using only
one copy of the up-split and right-split images instead of two).

c.  Modify the version of square-limit that uses square-of-four so as to
assemble the corners in a different pattern. (For example, you might make the
big Mr. Rogers look outward from each corner of the square.)

- Answer:

Boring one, skipped...

=== Exercise 2.53 ===
What would the interpreter print in response to evaluating each of the
following expressions?
{{{class="brush: scheme"
(list 'a 'b 'c)

(list (list 'george))
(cdr '((x1 x2) (y1 y2)))

(cadr '((x1 x2) (y1 y2)))
(pair? (car '(a short list)))
(memq 'red '((red shoes) (blue socks)))

(memq 'red '(red shoes blue socks))
}}}

- Answer:
{{{class="brush: scheme"
(list 'a 'b 'c)
; returns (a b c)

(list (list 'george))
; returns ((george))
(cdr '((x1 x2) (y1 y2)))
; returns ((y1 y2))

(cadr '((x1 x2) (y1 y2)))
; returns (y1 y2)
(pair? (car '(a short list)))
; returns #f
(memq 'red '((red shoes) (blue socks)))
; returns #f
(memq 'red '(red shoes blue socks))
; returns (red shoes blue socks)
}}}

=== Exercise 2.54 ===
Two lists are said to be equal? if they contain equal elements arranged in the
same order. For example, `(equal? '(this is a list) '(this is a list))` is
true, but `(equal? '(this is a list) '(this (is a) list))` is false.

To be more precise, we can define `equal?` recursively in terms of the basic
`eq?` equality of symbols by saying that a and b are equal? if they are both
symbols and the symbols are `eq?`, or if they are both lists such that `(car a)` is
`equal?` to `(car b)` and `(cdr a)` is `equal?` to ``(cdr b)``. Using this idea, implement
`equal?` as a procedure.

- Answer:

{{{class="brush: scheme"
(define (equal? a b)
    (let ((pa? (pair? a))
          (pb? (pair? b)))
    (cond ((and (null? a) (null? b)) #t)
          ((and (not pa?) (not pb?)) (eq? a b))
          ((or (and pa? (not pb?)) (and pb? (not pa?))) #f)
          (else (and (equal? (car a) (car b)) (equal? (cdr a) (cdr b)))))))
}}}

=== Exercise 2.55 ===
Eva Lu Ator types to the interpreter the expression `(car ''abracadabra)` To her
surprise, the interpreter prints back `quote`. Explain.

- Answer:

When you type `'abc` to the interpreter, the interpreter will return `(quote abc)`,
which means that the `'` notion is just an syntax sugar for `quote`. So `''abc`'
will become `'(quote abc)`, therefore `car` will return `quote`.

Exercise 2.56
Show how to extend the basic differentiator to handle more kinds of expressions.
For instance, implement the differentiation rule
$\frac{\rm{d}u^n}{\rm{d}x}=nu^{n-1}\frac{\rm{d}u}{\rm{d}x}$
by adding a new clause to the `deriv` program and defining appropriate procedures
`exponentiation?`, `base`, `exponent`, and `make-exponentiation`. (You may use the
symbol `**` to denote exponentiation.) Build in the rules that anything raised to
the power 0 is 1 and anything raised to the power 1 is the thing itself.

- Answer:

{{{class="bruch: scheme"
; implement the new rules
(define (make-exponentiation b e) 
    (cond ((number? b) (exp b e))
          ((= e 0) 1)
          ((= e 1) b)
          (else (list '** b e))))
(define base cadr)
(define exponent caddr)
(define (exponentiation? e) 
    (and (pair? e) (eq? '** (car e))))

; new deriv
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
           (make-product (multiplier exp)
                         (deriv (multiplicand exp) var))
           (make-product (deriv (multiplier exp) var)
                         (multiplicand exp))))
        ((exponentiation? exp) 
            (make-product 
                (exponent exp)
                (make-product (make-exponentiation (base exp) (- (exponent exp) 1))
                              (deriv (base exp) var))))
        (else
         (error "unknown expression type -- DERIV" exp))))
}}}

=== Exercise 2.57 ===
Extend the differentiation program to handle sums and products of arbitrary
numbers of (two or more) terms. Then the last example above could be expressed
as `(deriv '(* x y (+ x 3)) 'x)`.

Try to do this by changing only the
representation for `sums` and `products`, without changing the deriv procedure at
all. For example, the `addend` of a sum would be the first term, and the `augend`
would be the sum of the rest of the terms. 

- Answer:

{{{class="brush: scheme"
; sum
(define (make-sum . e)
    (let ((numbers (fold + 0 (filter (lambda (x) (number? x)) e)))
          (vars (filter (lambda (x) (not (number? x))) e)))
    (cond ((= 0 numbers)
        (cond ((null? vars) 0)
              ((null? (cdr vars)) (car vars))
              (else (cons '+ vars))))
          (else (cond ((null? vars) numbers)
                      (else (cons '+ (cons numbers vars))))))))
(define addend cadr)
(define (augend e)
    (let ((aug (cddr e)))
    (if (null? (cdr aug)) (car aug) (cons '+ aug))))

; products
(define (make-prouct . e)
    (let ((numbers (fold * 1 (filter (lambda (x) (number? x)) e)))
          (vars (filter (lambda (x) (not (number? x))) e)))
    (cond ((= 0 numbers) 0)
          ((= 1 numbers) (cond ((null? vars) 1)
                               ((null? (cdr vars)) (car vars))
                               (else (cons '+ vars))))
          (else (cond ((null? vars) numbers)
                      (else (cons '+ (cons numbers vars))))))))
(define multiplier cadr)
(define (multiplicand e)
    (let ((aug (cddr e)))
    (if (null? (cdr aug)) (car aug) (cons '* aug))))
}}}

One more thing, without a proper simplifier, the result is pretty messed up, and
no sane soul will write some thing like this:
{{{class="brush: scheme"
]=> (deriv '( * x x x x y) 'x)
    (+ (* x (+ (* x (+ (* x y) (* x y))) (* x x y))) (* x x x y))
}}}
This is indeed the correct answer, but badly shaped.

=== Exercise 2.58 ===
Suppose we want to modify the differentiation program so that it works with
ordinary mathematical notation, in which `+` and `*` are infix rather than prefix
operators. Since the differentiation program is defined in terms of abstract
data, we can modify it to work with different representations of expressions
solely by changing the predicates, selectors, and constructors that define the
representation of the algebraic expressions on which the differentiator is to
operate.

a. Show how to do this in order to differentiate algebraic expressions presented
in infix form, such as `(x + (3 * (x + (y + 2))))`. To simplify the task, assume
that `+` and `*` always take two arguments and that expressions are fully
parenthesized.

b. The problem becomes substantially harder if we allow standard algebraic
notation, such as `(x + 3 * (x + y + 2))`, which drops unnecessary parentheses and
assumes that multiplication is done before addition. Can you design appropriate
predicates, selectors, and constructors for this notation such that our
derivative program still works? 

- Answer:

a. With all proper parentheses in the expersion, it is an simple task.

{{{class="brush: scheme"
(define (make-sum e1 e2) 
    (cond ((and (number? e1) (= e1 0)) e2)
          ((and (number? e2) (= e2 0)) e1)
          ((and (number? e1) (number? e2)) (+ e1 e2))
          (else (list e1 '+ e2))))
(define (sum? e) (eq? '+ (cadr e)))
(define addend car)
(define augend caddr)

(define (make-product e1 e2)
    (cond ((or (=number? e1 0) (=number? e2 0)) 0)
          ((and (number? e1) (number? e2)) (* e1 e2))
          ((=number? e1 1) e2)
          ((=number? e2 1) e1)
          (else (list e1 '* e2))))
(define (product? e) (eq? '* (cadr e)))
(define multiplier car)
(define multiplicand caddr)
}}}

b. This one can be very complex. But here we only support two operation, `+` and
`*`, things will become much easier. Only need to change `augend` and
`multiplicand` in perivious exercise.

The idea is similiar to ex2.57, which is take the expersion as two part, the
first term, and the rest of it, without the operator in between. The only
different is we need to bundle the chain of `*` in `augend`, which basically trun 
`2 + 3 * 4 * 5 + 6` into `2 + (3 * 4 * 5) + 6`, and then, the `(3 * 4 * 5)` can
be processed in trun. This is to avoid the complicity because of precedence and
take advantage of the language itself.

{{{class="brush: scheme"
(define (augend e)
    ; the most complex part, need to bundle next chain of * into a list
    ; i.e. trun upcoming 4 * 5 * 6 + 7 to (4 * 5 * 6) + 7
    (define (helper in bundle)
        (let ((e  (car in))
              (es (cdr in)))
        (cond ((null? es) (if (null? bundle) e (append bundle (list '* e))))
              ((eq? (car es) '*) 
                (if (null? bundle) (helper (cdr es) (list e))
                    (helper (cdr es) (append bundle (list '* e)))))
              (else 
                (if (null? bundle) in 
                    (append (list (append bundle (list '* e))) es))))))
    (let ((t (cddr e)))
    (cond ((pair? (car t)) (car t))
          (else (helper t '())))))

; no need to bundle anything here, for * has the hiest precedence in this
; exercises
(define (multiplicand e)
    (cond ((pair? (caddr e)) (caddr e))
          (else (cddr e))))
}}}



%toc
