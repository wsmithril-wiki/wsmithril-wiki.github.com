<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <!--[if IE]><script type="text/javascript" src="../js/html5.js"></script><![endif]-->
    <link type="image/x-icon" rel="icon" href="/favicon.ico" />
    <link type="image/x-icon" rel="shortcut icon" href="/favicon.ico" />
    <link rel="stylesheet" type="text/css" href="/css/style.css" />
    <script type="text/javascript" src="/MathJax/MathJax.js?config=TeX-AMS-MML_SVG"></script>
    <title>SICP Exercises - Chapter 02 - Part. I</title>
</head>
<body>
    <div class="content">
    
<h1 id="toc_1">SICP Exercises</h1>
<h2 id="toc_1.1">Chapter 02 - Part.I</h2>

<h3 id="toc_1.1.1">Exercise 2.1</h3>
<p>
Define a better version of <code>make-rat</code> that handles both positive and negative
arguments. <code>make-rat</code> should normalize the sign so that if the rational number is
positive, both the numerator and denominator are positive, and if the rational
number is negative, only the numerator is negative.
</p>

<pre class="brush: scheme">
(define (sgn x)
    (cond ((= x 0) 0)
          ((&gt; x 0) 1)
          (else -1)))
(define (make-rat n d)
    (let ((an (abs n))
          (ad (abs d)))
    (let ((g (gcd an ad)))
    (cond ((= 0 an) (cons 0 1))
          ((= (sgn n) (sgn d)) (cons (/ an g) (/ ad g)))
          (else (cons (* -1 (/ an g)) (/ ad g)))))))
</pre>

<h3 id="toc_1.1.2">Exercise 2.2</h3>
<p>
Consider the problem of representing line segments in a plane. Each segment is
represented as a pair of points: a starting point and an ending point. Define
a constructor <code>make-segment</code> and selectors <code>start-segment</code> and <code>end-segment</code> that
define the representation of segments in terms of points. Furthermore, a point
can be represented as a pair of numbers: the x coordinate and the y coordinate.
Accordingly, specify a constructor <code>make-point</code> and selectors <code>x-point</code> and <code>y-point</code>
that define this representation. Finally, using your selectors and constructors,
define a procedure <code>midpoint-segment</code> that takes a line segment as argument and
returns its midpoint (the point whose coordinates are the average of the
coordinates of the endpoints). To try your procedures, you'll need a way to
print points:
</p>
<pre class="brush: scheme">
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
</pre>

<ul>
<li>
Answer:

</ul>

<pre class="brush: scheme">
(define make-point   cons)
(define make-segment cons)
(define start-segment car)
(define end-segment   cdr)
(define x-point car)
(define y-point cdr)

(define (mindpoint-segment seg)
    (make-point (average (x-point (start-segment seg)) (x-point (end-segment seg)))
                (average (y-point (start-segment seg)) (y-point (end-segment seg)))))
</pre>

<h3 id="toc_1.1.3">Exercise 2.3</h3>
<p>
Implement a representation for rectangles in a plane. (Hint: You may want to
make use of exercise 2.2.) In terms of your constructors and selectors, create
procedures that compute the perimeter and the area of a given rectangle. Now
implement a different representation for rectangles. Can you design your system
with suitable abstraction barriers, so that the same <code>perimeter</code> and <code>area</code>
procedures will work using either representation?
</p>

<pre class="brush: scheme">
(define (make-tringle a b c)
    (cons a (cons b c)))
(define (a-point t) (car t))
(define (b-point t) (car (cdr t)))
(define (c-point t) (cdr (cdr t)))

; another representation
(define (make-tringle a b c)
    (cons (cons a b) c))
(define (a-point t) (car (car t)))
(define (b-point t) (cdr (car t)))
(define (c-point t) (cdr t))

; some helper function
; inner product of vector ab and ac
(define (inner-porduct a b c)
    (+ (* (- (x-point b) (x-point a)) (- (x-point c) (x-point a)))
       (* (- (y-point b) (y-point a)) (- (y-point c) (y-point a)))))
(define (length-segment s)
    (let ((seg (make-point (- (x-point (end-segment s)) (x-point (start-segment s)))
                           (- (y-point (end-segment s)) (y-point (start-segment s))))))
    (sqrt (inner-product (cons 0 0) seg seg))))

; now  the area and perimeter should be identical to both representation
(define (perimeter t)
    (+ (segment-length (a-point t))
       (segment-length (b-point t))
       (segment-length (c-point t))))
(define (area t)
    (abs (inner-product (a-point t) (b-point t) (c-point t))))
</pre>

<h3 id="toc_1.1.4">Exercise 2.5</h3>
<p>
Show that we can represent pairs of nonnegative integers using only numbers and
arithmetic operations if we represent the pair \(a\) and \(b\) as the integer that is
the product \(2^a\cdot 3^b\). Give the corresponding definitions of the procedures
<code>cons</code>, <code>car</code>, and <code>cdr</code>.
</p>

<ul>
<li>
Answer:

</ul>

<pre class="brush: scheme">
(define (cons a b) (* (exp 2 a) (exp 3 b)))

; helper prodecure used in car and cdr
(define (in b n)
    (define (iter n t)
        (if (= 0 (remainder n b))
            (iter (/ n b) (+ t 1))
            (t)))
    (iter n 0))

; car and cdr
(define (car p) (in 2 p))
(define (cdr p) (in 3 p))
</pre>

<h3 id="toc_1.1.5">Exercise 2.6</h3>
<p>
In case representing pairs as procedures wasn't mind-boggling enough, consider
that, in a language that can manipulate procedures, we can get by without
numbers (at least insofar as nonnegative integers are concerned) by implementing
0 and the operation of adding 1 as
</p>
<pre class="brush: scheme">
(define zero (lambda (f) (lambda (x) x)))
(define (add-1 n) (lambda (f) (lambda (x) (f ((n f) x)))))
</pre>
<p>
This representation is known as Church numerals, after its inventor, Alonzo
Church, the logician who invented the \(\lambda\)-calculus.
</p>

<p>
Define <code>one</code> and <code>two</code> directly (not in terms of <code>zero</code> and <code>add-1</code>). (Hint: Use
substitution to evaluate <code>(add-1 zero)</code>). Give a direct definition of the addition
procedure <code>+</code> (not in terms of repeated application of <code>add-1</code>)
</p>

<ul>
<li>
Answer:

</ul>

<pre class="brush: scheme">
(define one (lambda (f) (lambda (x) (f x))))
(define two (lambda (f) (lambda (x) (f (f x)))))

(define (+ a b) (lambda (f) (lambda (x) ((a f) ((b f) x))))
</pre>

<h3 id="toc_1.1.6">Exercise 2.7</h3>
<p>
Alyssa's program is incomplete because she has not specified the implementation
of the interval abstraction. Here is a definition of the interval constructor:
</p>
<pre class="brush: scheme">
(define (make-interval a b) (cons a b))
</pre>
<p>
Define selectors <code>upper-bound</code> and <code>lower-bound</code> to complete the implementation.
</p>

<ul>
<li>
Answer:

</ul>

<pre class="brush: scheme"}>
(define upper-bound car)
(define lower-bound cdr)
</pre>

<h3 id="toc_1.1.7">Exercise 2.8</h3>
<p>
Using reasoning analogous to Alyssa's, describe how the difference of two
intervals may be computed. Define a corresponding subtraction procedure, called
<code>sub-interval</code>.
</p>

<ul>
<li>
Answer:

</ul>

<pre class="brush: scheme">
(define (sub-interval a b)
    (make-interval (- (lower-bound a) (upper-bound b))
                   (- (upper-bound a) (lower-bound b)))
</pre>

<h3 id="toc_1.1.8">Exercise 2.9</h3>
<p>
The width of an interval is half of the difference between its upper and lower
bounds. The width is a measure of the uncertainty of the number specified by the
interval. For some arithmetic operations the width of the result of combining
two intervals is a function only of the widths of the argument intervals,
whereas for others the width of the combination is not a function of the widths
of the argument intervals. Show that the width of the sum (or difference) of two
intervals is a function only of the widths of the intervals being added (or
subtracted). Give examples to show that this is not true for multiplication or
division.
</p>

<ul>
<li>
Answer:

</ul>

<p>
Simply notice the fact that sum of two interval, say \((a\pm \delta_a)\) and
\((b\pm \delta_b)\), is \(((a+b)\pm (\delta_a+\delta_b))\), shows that the width of
the sum of two interval is the sum of the width of the two.
</p>

<p>
And the width of the multiplication of two interval \((a\pm \delta_a)\) and
\((b\pm \delta_b)\) is \((ab \pm (b\delta_a+a\delta_b))\), assuming all interval
contain no negtive number, which shows that the width of the multiplication
of two interval is not only relate to the width of each interval, but also
relate to the lower nd upper bound of two interval itself.
</p>

<h3 id="toc_1.1.9">Exercise 2.10</h3>
<p>
Ben Bitdiddle, an expert systems programmer, looks over Alyssa's shoulder and
comments that it is not clear what it means to divide by an interval that spans
zero. Modify Alyssa's code to check for this condition and to signal an error if
it occurs.
</p>

<ul>
<li>
Answer:

</ul>

<pre class="brush: scheme">
(define (div-interval x y)
    (if (&lt;= (* (lower-bound y) (upper-bound)) 0)
        (error "divisor interval contains zero ")
        (mul-interval x
                      (make-interval (/ 1.0 (upper-bound y))
                                     (/ 1.0 (lower-bound y))))))
</pre>

<h3 id="toc_1.1.10">Exercise 2.11</h3>
<p>
In passing, Ben also cryptically comments: "By testing the signs of the
endpoints of the intervals, it is possible to break <code>mul-interval</code> into nine
cases, only one of which requires more than two multiplications." Rewrite this
procedure using Ben's suggestion.
</p>

<ul>
<li>
Answer:

</ul>

<pre class="brush: scheme">
(define (mul-interval x y)
    (define (pos-zero i)
        (let ((x (lower-bound i))
              (y (upper-bound i)))
        (cond ((and (&lt;  x 0) (&lt;  y 0)) -1)
              ((and (&lt;= x 0) (&gt;= y 0)) 0)
              ((and (&gt;  x 0) (&gt;  y 0)) 1))))
    (let ((tx (pos-zero x))
          (ty (pos-zero y)))
    (define (condition a b) (and (= tx a) (= ty b)))
    (define (mi v1 v2 v3 v4)
        (let ((f1 (if (= 0 v1) lower-bound upper-bound))
              (f2 (if (= 0 v2) lower-bound upper-bound))
              (f3 (if (= 0 v3) lower-bound upper-bound))
              (f4 (if (= 0 v4) lower-bound upper-bound)))
        (make-interval (* (f1 x) (f2 y)) (* (f3 x) (f4 y)))))
    (cond ((condition  1  1) (mi 0 0 1 1)) ; --0---[x]-[y]--
          ((condition -1 -1) (mi 1 1 0 0)) ; --[x]-[y]---0--
          ((condition  1 -1) (mi 0 1 1 0)) ; --[y]--0--[x]--
          ((condition -1  1) (mi 1 0 0 1)) ; --[x]--0--[y]--
          ((condition  0  1) (mi 0 1 1 1)) ; --[x-0-]--[y]--
          ((condition  0 -1) (mi 1 0 0 0)) ; --[y]--[x-0-]--
          ((condition  1  0) (mi 1 0 1 1)) ; --[y-0-]--[x]--
          ((condition -1  0) (mi 0 1 0 0)) ; --[x]--[y-0-]--
          (else make-interval (min (* (lower-bound x) (upper-bound y))
                                   (* (upper-bound x) (lower-bound y)))
                              (max (* (lower-bound x) (lower-bound y))
                                   (* (upper-bound x) (upper-bound y)))))))
</pre>

<h3 id="toc_1.1.11">Exercise 2.12</h3>
<p>
Define a constructor <code>make-center-percent</code> that takes a center and a percentage
tolerance and produces the desired interval. You must also define a selector
percent that produces the <code>percentage</code> tolerance for a given interval. The <code>center</code>
selector is the same as the one shown above. ]
</p>

<ul>
<li>
Answer:

</ul>

<pre class="brush: scheme">
(define (make-center-percent c p)
    (let ((hw (* c p)))
    (make-interval (- c hw) (+ c hw))))
(define (percent i)
    (abs (/ (width i) (center i))))
</pre>

<h3 id="toc_1.1.12">Exercise 2.13</h3>
<p>
Show that under the assumption of small percentage tolerances there is a simple
formula for the approximate percentage tolerance of the product of two intervals
in terms of the tolerances of the factors. You may simplify the problem by
assuming that all numbers are positive.
</p>

<ul>
<li>
Answer:

</ul>

<p>
Assume that two interval \(I_1\) and \(I_2\), that \(I_i=[c_i\pm c_i\cdot p_i]\), \((i=1,2)\),
and both interval are positive, the product of two interval would be
\(I=[(1-p_1)c_1\cdot (1-p_2)c_2, (1+p_1)c_1\cdot (1+p_2)c_2]=[c\pm cp]\), where
\(c=(1+\frac 12 p_2p_2)c_1c_2\), \(p=(p_1+p_2)/(1+\frac 12 p_1p_2)\). From the given
assumption that \(p_1\) and \(p_2\) is small enough that \(p_1p_2\) can be ignored.
So the product \(I\) has a simple approximation \(I_{approx}=[c_1c_2\pm c_1c_2(p_1+p_2)]\).
</p>

<h3 id="toc_1.1.13">Exercise 2.14</h3>
<p>
Demonstrate that Lem is right. Investigate the behavior of the system on
a variety of arithmetic expressions. Make some intervals \(A\) and \(B\), and use them
in computing the expressions \(A/A\) and \(A/B\). You will get the most insight by using
intervals whose width is a small percentage of the center value. Examine the
results of the computation in center-percent form (see exercise 2.12).
</p>

<ul>
<li>
Answer:

</ul>

<p>
With two interval \(A=10\pm 5%\) and \(B=20\pm 1%\), <code>par1</code> gives \(6.6830\pm 8.132%\)
while <code>par2</code> yields \(6.6643\pm 3.668%\).
</p>

<p>
The result of \(A/A=1.005\pm 9.975%\), \(B/B=1.0002\pm 1.9998%\), \(A/B=0.5003\pm 5.997%\).
shows that basically after the <code>div-interval</code>, the <code>percent</code> of the two interval
is the sum of both (as in 2.13). So the error will easily accumulate along with
the process of evaluation. As for percedure <code>par1</code>, there are 3 interval
arithmetic, namely <code>(add-interval r1 r2)</code>, <code>(mul-interval r1 r2)</code> and the
<code>div-interval</code> of pervious two. Therefore the error get accumulated 3 times. While the
procedure <code>par2</code>, only the add of the two reverse involves interval arithmetic,
since <code>one</code> is not actually an interval, result in a more accurate result.
</p>

<p>
The error analysis shows that the \(R=\frac{R_1R_2}{R_1+R_2}\) gives an error of
\((\frac{\delta_R}{R})^2=(\frac{\delta_{R_1}}{R_1})^2+(\frac{\delta_{R_2}}{R_2})^2+\delta_{R_1}^2+\delta_{R_2}^2\),
while \(R'=\frac{1}{\frac{1}{R_1}+\frac{1}{R_2}}\) only has an error of
\({\delta_{R'}}^2=\delta_{R_1}^2+{\delta_{R_2}}^2\), which is much smaller.
</p>

<h3 id="toc_1.1.14">Exercise 2.15</h3>
<p>
Eva Lu Ator, another user, has also noticed the different intervals computed by
different but algebraically equivalent expressions. She says that a formula to
compute with intervals using Alyssa's system will produce tighter error bounds
if it can be written in such a form that no variable that represents an
uncertain number is repeated. Thus, she says, <code>par2</code> is a "better" program for
parallel resistances than <code>par1</code>. Is she right? Why?
</p>

<ul>
<li>
Answer:

</ul>

<p>
For the most case, this is correct, for in each step of evaluation, the error
gets accumulated. Therefore, the lesser expersion with number with error, the
better. But in some cases, the algebraically equivlent is needed to prevent
underflow from happenning.
</p>

<h3 id="toc_1.1.15">Exercise 2.16</h3>
<p>
Explain, in general, why equivalent algebraic expressions may lead to different
answers. Can you devise an interval-arithmetic package that does not have this
shortcoming, or is this task impossible? (Warning: This problem is very
difficult.)
</p>

<ul>
<li>
Answer:

</ul>

<p>
This is indeed a very diffcult one. I think it is impossible to devise such
interval-arithmetic package. One strong reason is the <code>error analysis</code> in ex
2.14, which shows that the how a value calculated dose and should effect its
accuracy.
</p>

<p>
To interval arithmetic, certain laws which is known to be true in real number
dose not fits in. For example, if the basic arithmetic of intervla defined as
follow:
</p>
\[
\begin{alignat}{3}
  [a,b] &amp;+&amp;[c,d] &amp;=  [a+b &amp; &amp;, c+d] \cr
  [a,b] &amp;\times&amp; [c,d] &amp;= [\min(ac,ad,bc,bd) &amp; &amp;, \max(ac,ad,bc,bd)] \cr
\end{alignat}
\]
<p>
Then all interval, denoted as \(\rm{I}\), along with each of these two operator
does not form an group. And with these two operator law of distribute does not
applied (\(A(B+C)\) is not equals to \(AB+AC\), \(A,B,C\in\rm{I}\), in fact, \(A(B+C)\subset AB+AC\)).
</p>

<h3 id="toc_1.1.16">Exercise 2.17</h3>
<p>
Define a procedure last-pair that returns the list that contains only the last
element of a given (nonempty) list:
</p>
<pre class="brush: scheme">
(last-pair (list 23 72 149 34))
(34)
</pre>

<ul>
<li>
Answer:

</ul>

<pre class="brush: scheme">
(define (last-pair xs)
    (if (null? xs)
        (list)
        (let ((x    (car xs))
              (rest (cdr xs)))
             (if (null? xs)
                (list x)
                (last-pair xs)))))
</pre>

<h3 id="toc_1.1.17">Exercise 2.18</h3>
<p>
Define a procedure reverse that takes a list as argument and returns a list of
the same elements in reverse order:
</p>

<pre class="brush: scheme">
(reverse (list 1 4 9 16 25))
(25 16 9 4 1)
</pre>

<ul>
<li>
Answer:

</ul>

<pre class="brush: scheme">
(define (reverse xs)
    (define (iter xs rs)
        (if (null? xs)
            rs
            (iter (cdr xs) (cons (car xs) rs))))
    (iter xs (list)))
</pre>

<h3 id="toc_1.1.18">Exercise 2.19</h3>
<p>
Consider the <code>change-counting</code> program of section 1.2.2. It would be nice to be
able to easily change the currency used by the program, so that we could compute
the number of ways to change a British pound, for example. As the program is
written, the knowledge of the currency is distributed partly into the procedure
<code>first-denomination</code> and partly into the procedure <code>count-change</code> (which knows that
there are five kinds of U.S. coins). It would be nicer to be able to supply
a list of coins to be used for making change.
</p>

<p>
We want to rewrite the procedure <code>cc</code> so that its second argument is a list of the
values of the coins to use rather than an integer specifying which coins to use.
We could then have lists that defined each kind of currency:
</p>

<pre class="brush: scheme">
(define us-coins (list 50 25 10 5 1))
(define uk-coins (list 100 50 20 10 5 2 1 0.5))
</pre>

<p>
We could then call cc as follows:
</p>

<pre class="brush: scheme"">
(cc 100 us-coins)
292
</pre>

<p>
To do this will require changing the program <code>cc</code> somewhat. It will still have the
same form, but it will access its second argument differently, as follows:
</p>

<pre class="brush: scheme">
(define (cc amount coin-values)
  (cond ((= amount 0) 1)
        ((or (&lt; amount 0) (no-more? coin-values)) 0)
        (else
         (+ (cc amount
                (except-first-denomination coin-values))
            (cc (- amount
                   (first-denomination coin-values))
                coin-values)))))
</pre>

<p>
Define the procedures <code>first-denomination</code>, <code>except-first-denomination</code>, and
no-more? in terms of primitive operations on list structures. Does the order of
the list <code>coin-values</code> affect the answer produced by <code>cc</code>? Why or why not?
</p>

<ul>
<li>
Answer:

</ul>

<pre class="brush: scheme">
(define first-denomination car)
(define except-first-denomination cdr)
(define no-more? null?)
</pre>

<h3 id="toc_1.1.19">Exercise 2.20</h3>
<p>
The procedures <code>+</code>, <code>*</code>, and <code>list</code> take arbitrary numbers of arguments. One way to
define such procedures is to use define with <code>dotted-tail</code> notation. In a
procedure definition, a parameter list that has a dot before the last parameter
name indicates that, when the procedure is called, the initial parameters (if
any) will have as values the initial arguments, as usual, but the final
parameter's value will be a list of any remaining arguments. For instance,
given the definition
</p>

<pre class="brush: scheme">
(define (f x y . z) &lt;body&gt;)
</pre>

<p>
The procedure f can be called with two or more arguments. If we evaluate
<code>(f 1 2 3 4 5 6)</code>, then in the body of f, <code>x</code> will be <code>1</code>, <code>y</code> will be <code>2</code>, and
<code>z</code> will be the list <code>(3 4 5 6)</code>. Given the definition <code>(define (g . w) &lt;body&gt;)</code>,
the procedure <code>g</code> can be called with zero or more arguments. If we evaluate
<code>(g 1 2 3 4 5 6)</code>, then in the body of <code>g</code>, <code>w</code> will be the list <code>(1 2 3 4 5 6)</code>
</p>

<p>
Use this notation to write a procedure <code>same-parity</code> that takes one or more
integers and returns a list of all the arguments that have the same <code>even-odd</code>
parity as the first argument. For example,
</p>

<pre class="brush: scheme">
(same-parity 1 2 3 4 5 6 7)
(1 3 5 7)

(same-parity 2 3 4 5 6 7)
(2 4 6)
</pre>

<ul>
<li>
Answer:

</ul>

<pre class="brush: scheme">
(define (same-parity x . xs)
    (define (iter is rs)
        (cond ((null? is) (reverse rs))
              ((even? (- (car is) x)) (iter (cdr is) (cons (car is) rs)))
              (else (iter (cdr is) rs))))
    (iter xs (list x)))
</pre>

<h3 id="toc_1.1.20">Exercise 2.21</h3>
<p>
The procedure <code>square-list</code> takes a list of numbers as argument and returns a list
of the squares of those numbers.
</p>

<pre class="brush: scheme">
(square-list (list 1 2 3 4))
(1 4 9 16)
</pre>

<p>
Here are two different definitions of <code>square-list</code>. Complete both of them by
filling in the missing expressions:
</p>

<pre class="brush: scheme">
(define (square-list items)
  (if (null? items)
      nil
      (cons &lt;??&gt; &lt;??&gt;)))
(define (square-list items)
  (map &lt;??&gt; &lt;??&gt;))
</pre>

<ul>
<li>
Answer:

</ul>

<pre class="brush: scheme">
; the recursive way
(cons (square (car items)) (square-list (cdr items)))

; using map
(map square items)
</pre>

<h3 id="toc_1.1.21">Exercise 2.22</h3>
<p>
Louis Reasoner tries to rewrite the first <code>quare-list</code> procedure of exercise 2.21
so that it evolves an iterative process:
</p>

<pre class="brush: scheme">
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons (square (car things))
                    answer))))
  (iter items nil))
</pre>

<p>
Unfortunately, defining <code>square-list</code> this way produces the answer list in the
reverse order of the one desired. Why?
</p>

<p>
Louis then tries to fix his bug by interchanging the arguments to <code>cons</code>:
</p>

<pre class="brush: scheme">
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons answer
                    (square (car things))))))
  (iter items nil))
</pre>

<p>
This doesn't work either. Explain.
</p>

<ul>
<li>
Answer:

</ul>

<p>
The first attemp get the answer in reverse order is because how the answer list
been constructed. This precedure take the first member of the list, square it,
and push it to the answer list, in which way the first number in the list will
become the last one in the answer list.
</p>

<p>
The second attemp fails for how a list is represtented in Scheme. A proper way
to represent the list <code>(square-list (list 1 2 3 4))</code> would be
<code>(cons 1 (cons 4 (cons 9 (cons 16 nil))))</code>, but the second one gives
<code>(cons (cons (cons (cons 1 nil) 4) 9) 16)</code>, which is obviously the wrong one.
</p>

<h3 id="toc_1.1.22">Exercise 2.23</h3>
<p>
The procedure <code>for-each</code> is similar to <code>map</code>. It takes as arguments a procedure and
a list of elements. However, rather than forming a list of the results,
<code>for-each</code> just applies the procedure to each of the elements in turn, from left to right.
The values returned by applying the procedure to the elements are not used at
all -- <code>for-each is</code> used with procedures that perform an action, such as
printing. For example,
</p>

<pre class="brush: scheme">
(for-each (lambda (x) (newline) (display x))
          (list 57 321 88))
57
321
88
</pre>

<p>
The value returned by the call to <code>for-each</code> (not illustrated above) can be
something arbitrary, such as true. Give an implementation of <code>for-each</code>.
</p>

<ul>
<li>
Answer:

</ul>

<pre class="brush: scheme">
(define (for-each p xs)
    (if (null? xs) (list)
        ((p (car x)) (for-each p (cdr xs)))))
</pre>

<p>
Noted that <code>for-each</code> is not the same as <code>map</code>, while <code>(define for-each map)</code>
seems fine, which, in fact, is not. For <code>for-each</code> should ensure that the given
precedure should be strictly applied to each element in the list from the left
to right, while <code>map</code> dose not need to be guarantee that.
</p>

<h3 id="toc_1.1.23">Exercise 2.24</h3>
<p>
Suppose we evaluate the expression <code>(list 1 (list 2 (list 3 4)))</code>.  Give the
result printed by the interpreter, the corresponding box-and-pointer structure,
and the interpretation of this as a tree.
</p>

<ul>
<li>
Answer:

</ul>

<p>
The interpreter will show <code>(1 (2 (3 4)))</code>
</p>

<h3 id="toc_1.1.24">Exercise 2.25</h3>
<p>
Give combinations of <code>car</code>s and <code>cdr</code>s that will pick 7 from each of the following
lists:
</p>

<pre class="brush: scheme">
(1 3 (5 7) 9)
((7))
(1 (2 (3 (4 (5 (6 7))))))
</pre>

<ul>
<li>
Answer:

<ul>
<li>
<code>(car (cdr (car (cdr (cdr list)))))</code> returns <code>7</code>

<li>
<code>(car (car list))</code> returns <code>7</code>

<li>
<code>(car (cdr (cdr (cdr (cdr (cdr (cdr list)))))))</code> picks <code>7</code>

</ul>
</ul>

<p>
Noted that <code>(7)</code> is actually <code>(cons 7 nil)</code> for short, the nil is ommited when
displaying. So the first <code>car</code> is nessery in each answer.
</p>

<h3 id="toc_1.1.25">Exercise 2.26</h3>
<p>
Suppose we define x and y to be two lists:
</p>

<pre class="brush:scheme>
(define x (list 1 2 3))
(define y (list 4 5 6))
</pre>

<p>
What result is printed by the interpreter in response to evaluating each of the following expressions:
</p>

<pre class="brush: scheme">
(append x y)
(cons x y)
(list x y)
</pre>

<ul>
<li>
Answer:

</ul>

<pre class="brush: scheme">
]=&gt; (append x y)
(1 2 3 4 5 6)
]=&gt; (cons x y)
((1 2 3) 4 5 6)
]=&gt; (list x y)
((1 2 3) (4 5 6))
</pre>

<h3 id="toc_1.1.26">Exercise 2.27</h3>
<p>
Modify your <code>reverse</code> procedure of exercise 2.18 to produce a <code>deep-reverse</code>
procedure that takes a list as argument and returns as its value the list with
its elements reversed and with all sublists <code>deep-reversed</code> as well. For example,
</p>

<pre class="brush: scheme">
(define x (list (list 1 2) (list 3 4)))

(reverse x)
((3 4) (1 2))

(deep-reverse x)
((4 3) (2 1))
</pre>

<ul>
<li>
Answer:

</ul>

<pre class="brush: scheme">
(define (deep-reverse lls)
    (if (pair? lls) (reverse (map deep-reverse lls))
        lls))
</pre>

<p>
Exercise 2.28
Write a procedure <code>fringe</code> that takes as argument a tree (represented as a list)
and returns a list whose elements are all the leaves of the tree arranged in
left-to-right order. For example,
</p>

<pre class="brush: scheme">
(define x (list (list 1 2) (list 3 4)))

(fringe x)
(1 2 3 4)

(fringe (list x x))
(1 2 3 4 1 2 3 4)
</pre>

<ul>
<li>
Answer:

</ul>

<pre class="brush: scheme">
(define (fringe ls)
    (cond ((null? ls) (list))
          ((not (pair? (car ls))) (cons (car ls) (fringe (cdr ls))))
          (else (append (fringe (car ls)) (fringe (cdr ls))))))
</pre>

<h3 id="toc_1.1.27">Exercise 2.29</h3>
<p>
A binary mobile consists of two branches, a left branch and a right branch. Each
branch is a rod of a certain length, from which hangs either a weight or another
binary mobile. We can represent a binary mobile using compound data by
constructing it from two branches (for example, using list):
</p>

<pre class="brush: scheme:">
(define (make-mobile left right)
  (list left right))
</pre>

<p>
A branch is constructed from a length (which must be a number) together with
a structure, which may be either a number (representing a simple weight) or
another mobile:
</p>

<pre class="brush: scheme">
(define (make-branch length structure)
  (list length structure))
</pre>

<p>
a.  Write the corresponding selectors <code>left-branch</code> and <code>right-branch</code>, which return
the branches of a mobile, and <code>branch-length</code> and <code>branch-structure</code>, which return
the components of a branch.
</p>

<ul>
<li>
Answer:

</ul>

<pre class="brush: scheme">
(define (left-branche    car)
(define (right-branch x) (car (cdr x)))
(define branche-length car)
(define branche-structure (lambda (x) (car (cdr x))))
</pre>

<p>
b.  Using your selectors, define a procedure <code>total-weight</code> that returns the total
weight of a mobile.
</p>

<pre class="brush: scheme">
(define (total-weight mobile)
    (define (struct-weight st)
        (if (pair? st) (total-weight st) st))
    (let ((sl (branche-structure (left-branche  mobile)))
          (sr (branche-structure (right-branche mobile))))
    (+ (struct-weight sl) (struct-weight sr))))
</pre>

<p>
c.  A mobile is said to be balanced if the torque applied by its top-left branch
is equal to that applied by its top-right branch (that is, if the length of the
left rod multiplied by the weight hanging from that rod is equal to the
corresponding product for the right side) and if each of the submobiles hanging
off its branches is balanced. Design a predicate that tests whether a binary
mobile is balanced.
</p>

<ul>
<li>
Answer:

</ul>

<pre class="brush: scheme">
(define (balance? m)
    (let ((sl (branche-structure (left-branche  m)))
          (sr (branche-structure (right-branche m)))
          (ll (branche-length (left-branche  m)))
          (lr (branche-length (right-branche m))))
    (if (and (pair? sl) (pair? sr))
        (= (* ll sl) (* lr sr))
        (and (balance? sl) (balance? sr)
             ( = (* ll (total-weight sl))
                 (* lr (total-weight sr)))))))
</pre>

<p>
d.  Suppose we change the representation of mobiles so that the constructors are
</p>

<pre class="brush: scheme">
(define (make-mobile left right)
  (cons left right))
(define (make-branch length structure)
  (cons length structure))
</pre>

<p>
How much do you need to change your programs to convert to the new representation?
</p>

<ul>
<li>
Answer:

</ul>

<p>
Only these selectors
</p>

<pre class="brush: scheme">
(define left-branche  car)
(define right-branche cdr)
(define branche-length    car)
(define branche-structure cdr)
</pre>

<h3 id="toc_1.1.28">Exercise 2.33</h3>
<p>
Fill in the missing expressions to complete the following definitions of some
basic list-manipulation operations as accumulations:
</p>

<pre class="brush:scheme">
(define (map p sequence)
  (accumulate (lambda (x y) &lt;??&gt;) nil sequence))
(define (append seq1 seq2)
  (accumulate cons &lt;??&gt; &lt;??&gt;))
(define (length sequence)
  (accumulate &lt;??&gt; 0 sequence))
</pre>

<ul>
<li>
Answer:
<pre class="brush:scheme">
(define (map p sequence)
  (accumulate (lambda (x y) (cons (p x) y)) nil sequence))
(define (append seq1 seq2)
  (accumulate cons seq2 seq1))
(define (length sequence)
  (accumulate (lambda (x y) (+ x 1)) 0 sequence))
</pre>

</ul>

<h3 id="toc_1.1.29">Exercise 2.34</h3>
<p>
Evaluating a polynomial in \(x\) at a given value of \(x\) can be formulated as an
accumulation. We evaluate the polynomial \(f(x)=\sum_{i=1}^n a_ix^i\) using
a well-known algorithm called Horner's rule, which structures the computation as
\(f(x)=(\cdots(a_nx+a_{n-1})x+\cdots +a_1)x+a_0\). In other words, we start with
\(a_n\), multiply by \(x\), add \(a_{n-1}\), multiply by \(x\), and so on, until we
reach \(a_0\). Fill in the following template to produce a procedure that evaluates
a polynomial using Horner's rule. Assume that the coefficients of the polynomial
are arranged in a sequence, from \(a_0\) through \(a_n\).
</p>

<pre class="brush: scheme">
(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms) &lt;??&gt;)
              0
              coefficient-sequence))
</pre>

<p>
For example, to compute \(1+3x+5x^3+x^5\) at \(x=2\) you would evaluate
</p>

<pre class="brush: scheme">
(horner-eval 2 (list 1 3 0 5 0 1))
</pre>

<ul>
<li>
Answer:

</ul>

<p>
Only the <code>lambda</code> part:
</p>
<pre class="brush: scheme">
(lambda (this-coeff higher-terms) (+ this-coeff (* x higher-terms)))
</pre>

<p>
The porpurse of Horner's rule is to reduce the arithmetic operation being used
when evaluation, which reduce the times of multiplication from \(2n-1\), when
evaluating term by term, to \(n\), while the times of addition is both \(n\).
</p>

<h3 id="toc_1.1.30">Exercise 2.35</h3>
<p>
Redefine <code>count-leaves</code> from section 2.2.2 as an <code>accumulation</code>:
</p>

<pre class="brush: scheme">
(define (count-leaves t)
  (accumulate &lt;??&gt; &lt;??&gt; (map &lt;??&gt; &lt;??&gt;)))
</pre>

<ul>
<li>
Answer:

</ul>

<pre class="brush: scheme">
(define (count-leaves t)
    (accumulate + 0 (map (lambda (x) 1) (enumerate-tree t))))
</pre>

<h3 id="toc_1.1.31">Exercise 2.36</h3>
<p>
The procedure <code>accumulate-n</code> is similar to accumulate except that it takes as its
third argument a sequence of sequences, which are all assumed to have the same
number of elements. It applies the designated accumulation procedure to combine
all the first elements of the sequences, all the second elements of the
sequences, and so on, and returns a sequence of the results. For instance, if s
is a sequence containing four sequences, <code>((1 2 3) (4 5 6) (7 8 9) (10 11 12))</code>,
then the value of <code>(accumulate-n + 0 s)</code> should be the sequence <code>(22 26 30)</code>. Fill
in the missing expressions in the following definition of <code>accumulate-n</code>:
</p>

<pre class="brush: scheme">
(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op init &lt;??&gt;)
            (accumulate-n op init &lt;??&gt;))))
</pre>

<ul>
<li>
Answer:

</ul>

<pre class="brush: scheme">
; first &lt;??&gt;
(map car seqs)
; second &lt;??&gt;
(map cdr seqs)
</pre>

<h3 id="toc_1.1.32">Exercise 2.37</h3>
<p>
Suppose we represent vectors \(v=(v_i)\) as sequences of numbers, and matrices
\(m=(m_{ij})\) as sequences of vectors (the rows of the matrix). For example, the
matrix
</p>
\[
\begin{bmatrix}
1 &amp; 2 &amp; 3 &amp; 4 \\ 4 &amp; 5 &amp; 6 &amp; 6 \\ 6 &amp; 7 &amp; 8 &amp; 9
\end{bmatrix}
\]
<p>
is represented as the sequence <code>((1 2 3 4) (4 5 6 6) (6 7 8 9))</code>. With this
representation, we can use sequence operations to concisely express the basic
matrix and vector operations. These operations (which are described in any book
on matrix algebra) are the following:
</p>

<p>
We can define the dot product as:
</p>

<pre class="brush: scheme">
(define (dot-product v w)
  (accumulate + 0 (map * v w)))
</pre>

<p>
Fill in the missing expressions in the following procedures for computing the
other matrix operations. (The procedure <code>accumulate-n</code> is defined in exercise
2.36.)
</p>

<pre class="brush: scheme">
(define (matrix-*-vector m v)
  (map &lt;??&gt; m))
(define (transpose mat)
  (accumulate-n &lt;??&gt; &lt;??&gt; mat))
(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map &lt;??&gt; m)))
</pre>

<ul>
<li>
Answer:

</ul>

<pre class="brush: scheme">
(define (martix-*-vector m v)
  (map (lambda (r) (dot-product r v) m)))
(define (transpose mat)
  (accumulate-n cons nil mat))
(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map (lambda (r) (matrix-*-vector col r) m)))
</pre>

<h3 id="toc_1.1.33">Exercise 2.38</h3>
<p>
The accumulate procedure is also known as <code>fold-right</code>, because it combines the
first element of the sequence with the result of combining all the elements to
the right. There is also a <code>fold-left</code>, which is similar to <code>fold-right</code>, except
that it combines elements working in the opposite direction:
</p>

<pre class="brush: scheme">
(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))
</pre>

<p>
Give a property that op should satisfy to guarantee that <code>fold-right</code> and
<code>fold-left</code> will produce the same values for any sequence.
</p>

<ul>
<li>
Answer:

</ul>

<p>
Consider <code>(fold-left op init (list a1 a2 a3 a4))</code> and <code>(fold-right op init (list a1 a2 a3 a4))</code>,
the resule is something like this (using Haskell style infix notion to make
thing clear):
</p>

<pre class="brush: haskell">
-- fold-left
((((a1 `op` a2) `op` a3) `op` a4) `op` init)
-- fold-right
(a1 `op` (a2 `op` (a3 `op` (a4 `op` init))))
</pre>

<p>
Their difference lies in the order of computation, which clear suggests that the
<code>fold-right</code> and <code>fold-left</code> return the same result for any list when the <code>op</code>
satisfy the Rule of Combination, whohich means that in a "chain" of same <code>op</code>,
which <code>op</code> gets computed first does not affact the result.
</p>

<h3 id="toc_1.1.34">Exercise 2.39</h3>
<p>
Complete the following definitions of <code>reverse</code> (exercise 2.18) in terms of
<code>fold-right</code> and <code>fold-left</code> from exercise 2.38:
</p>

<pre class="brush: scheme">
(define (reverse sequence)
  (fold-right (lambda (x y) &lt;??&gt;) nil sequence))
(define (reverse sequence)
  (fold-left (lambda (x y) &lt;??&gt;) nil sequence))
</pre>

<ul>
<li>
Answer:

</ul>

<pre class="brush: scheme ">
(define (reverse sequence)
  (fold-right (lambda (x y) (append y (list x))) nil sequence))
(define (reverse sequence)
  (fold-left (lambda (x y) (cons y x)) nil sequence))
</pre>

<h3 id="toc_1.1.35">Exercise 2.40</h3>
<p>
Define a procedure <code>unique-pairs</code> that, given an integer <code>n</code>, generates the
sequence of pairs \((i,j)\) with \(1\le j\lt i\le n\). Use <code>unique-pairs</code> to
simplify the definition of <code>prime-sum-pairs</code> given above.
</p>

<pre class="brush: scheme">
(define (unique-pairs n)
  (accumulate append '()
              (map (lambda (i)
                           (map (lambda (j) (list i j))
                                (enumerate-interval (- i 1))))
                   (enumerate-interval n))))
(define (prime-sum-pairs n)
  (map (lambda (p) (append p (list (+ p))))
       (filter (lambda (p) (prime? (+ p)))
               (unique-pairs n))))
</pre>

<h3 id="toc_1.1.36">Exercise 2.41</h3>
<p>
Write a procedure to find all ordered triples of distinct positive integers i,
j, and k less than or equal to a given integer n that sum to a given integer s.
</p>

<ul>
<li>
Answer:

</ul>

<pre class="brush: scheme">
(define (find-sum-s n s)
  (filter (lambda (t) (= (+ t) s)) (uniq-triple n)))
(define (uniq-triple n)
  (flatmap (lambda (i) (map (lambda (p) (cons i p)) (unique-pqir i)))
           (enumerate-interval n)))
</pre>

    </div>

    <div class="copyright">
        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/"><img alt="知识共享许可协议" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/2.5/cn/88x31.png" /></a>
        <br />
        本作品由<span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">WsMithril</span>创作，采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/">知识共享署名-非商业性使用-相同方式共享 2.5 中国大陆许可协议</a>进行许可。
    </div>
     
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'wsmithrilswiki'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

    <footer>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </footer>


</body>
<link rel="stylesheet" type="text/css" href="/SyntaxHighlighter/styles/shThemeMidnight.css" />
<script type="text/javascript" src="/SyntaxHighlighter/scripts/shCore.js"></script>
<script type="text/javascript" src="/SyntaxHighlighter/scripts/shAutoloader.js"></script>

<script type="text/javascript">
    SyntaxHighlighter.autoloader(
      'applescript            /SyntaxHighlighter/scripts/shBrushAppleScript.js',
      'actionscript3 as3      /SyntaxHighlighter/scripts/shBrushAS3.js',
      'bash shell             /SyntaxHighlighter/scripts/shBrushBash.js',
      'coldfusion cf          /SyntaxHighlighter/scripts/shBrushColdFusion.js',
      'cpp c                  /SyntaxHighlighter/scripts/shBrushCpp.js',
      'c# c-sharp csharp      /SyntaxHighlighter/scripts/shBrushCSharp.js',
      'css                    /SyntaxHighlighter/scripts/shBrushCss.js',
      'delphi pascal          /SyntaxHighlighter/scripts/shBrushDelphi.js',
      'diff patch pas         /SyntaxHighlighter/scripts/shBrushDiff.js',
      'erl erlang             /SyntaxHighlighter/scripts/shBrushErlang.js',
      'groovy                 /SyntaxHighlighter/scripts/shBrushGroovy.js',
      'java                   /SyntaxHighlighter/scripts/shBrushJava.js',
      'jfx javafx             /SyntaxHighlighter/scripts/shBrushJavaFX.js',
      'js jscript javascript  /SyntaxHighlighter/scripts/shBrushJScript.js',
      'perl pl                /SyntaxHighlighter/scripts/shBrushPerl.js',
      'php                    /SyntaxHighlighter/scripts/shBrushPhp.js',
      'text plain             /SyntaxHighlighter/scripts/shBrushPlain.js',
      'py python              /SyntaxHighlighter/scripts/shBrushPython.js',
      'ruby rails ror rb      /SyntaxHighlighter/scripts/shBrushRuby.js',
      'sass scss              /SyntaxHighlighter/scripts/shBrushSass.js',
      'scala                  /SyntaxHighlighter/scripts/shBrushScala.js',
      'sql                    /SyntaxHighlighter/scripts/shBrushSql.js',
      'vb vbnet               /SyntaxHighlighter/scripts/shBrushVb.js',
      'xml xhtml xslt html    /SyntaxHighlighter/scripts/shBrushXml.js',
      'scheme                 /SyntaxHighlighter/scripts/shBrushScheme.js',
      'hs haskell             /SyntaxHighlighter/scripts/shBrushHaskell.js',
      'asm x86 Asm            /SyntaxHighlighter/scripts/shBrushAsm.js'
    );
    SyntaxHighlighter.defaults['toolbar']    = false;
    SyntaxHighlighter.defaults['gutter']     = true;
    SyntaxHighlighter.defaults['smart-tabs'] = true;
    SyntaxHighlighter.defaults['ruler']      = true;
    SyntaxHighlighter.defaults['tab-size']   = 4;
    SyntaxHighlighter.all();
</script>
</html>
